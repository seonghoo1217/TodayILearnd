Websocket은 단순한 통신구조를 갖고 있기 때문에, 순수 Websocket만으로는 해당 메시지가 어떤 요청인지, 어떻게 처리해야하는지를 처리하는데 있어 까다로움을 가지고있다.

# What is Stomp?

**STOMP(Simple Text Oriented Messaging Protocol)**은 메세징 전송을 효율적을 하기 위해 탄생한 웹 소켓 프로토콜 중 하나이다.

웹 브라우저에서 **발행 구독 패턴(Pub-Sub Pattern)을** 기반으로 실시간 메시징을 지원할 수 있기 때문에 이점이 있어 이번 프로젝트에서도 테트리스들의 블록에 대한 Canvas의 위치값을 전송하기 위해 사용하게 되었다.

또한, STOMP를 사용하여 메세지의 헤더에 값을 줄 수 있어 헤더 값을 기반으로 통신 시 인증처리에 대한 이슈를 해결할 수 있었다.

자 그럼 STOMP의 동작 방식에 대해 이제 알아볼건데 그 전에 발행 구독 패턴부터 먼저 살펴보자

## 💡 발행 구독 패턴

옵저버 패턴과 유사한 디자인 패턴이다.

일반적으로 **`발행자(Publisher)`와 `구독자(Subscriber)`**가 존재하고, 그 사이에 브로커( = Message Queue)가 존재하는 형태이다.

요약하자면, 발행자가 수신자에게 Message를 전달하는 것이아닌, 구독을 신청한 모든 수신자들에게 전달된다.

### 발행자와 구독자의 특징

1. pub이 sub의 선언 위치나 존재를 알 필요가 없다.

- 메시지 큐와 같은 브로커 역할을 하는 중간 지점에 메시지를 던져 두기만 하면, 브로커가 알아서 처리한다.

2. sub 역시 pub의 선언 위치나 존재를 알 필요가 없다.

- 브로커에 할당된 작업만을 모니터링하고, 원하는 작업이 발생하면 할당받아 작업을 수행하면 된다.

그러므로 pub, sub은 서로 알 필요가 없으며, 브로커와의 통신만을 수행할 수 있다면 역할을 잘 수행하는 것이다.

### **브로커**

브로커는 발행자와 구독자 사이에 위치하고 있다.

주로 메시지큐가 브로커로서의 역할을 수행하며, 두 객체 사이에서 구독과 발행 이후의 메시지를 처리해준다.

즉, 브로커가 모든 들어오는 메시지를 필터링하며, 타겟들(=구독자)에게 메시지를 배포하는 역할을 한다.

### 메시지 큐

대용량 데이터 처리를 위한 배치 작업이나 채팅 서비스, 비동기 데이터 처리등에 이용한다.

즉, 대부분 비동기와 대규모 처리에 적합한 작업에 사용된다.

이를 메시지 지향 미들웨어(MOM = Message Oriented Middleware)를 지향하는 서비스라고 볼 수 있다.

앞서 말했듯이 비동기처리와 확장성이 커 여러 프로세스에 메시지를 전달할 수도있으며, 장애전파 또한 일어나지않는다는 장점이 있다.

하지만, Queue의 형태를 가지기에 트래픽이 몰리면 대기시간 지연으로 서비스가 망가질 가능성이있다.

# Stomp의 동작방식

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/db74ba2d-24e4-4d4b-ae5c-07d99cd33ca1/83af668f-347b-4b84-a60c-e733a59b3f96/Untitled.png)

**`STOMP` 는** 기본적으로 **스트리밍 텍스트 지향 메시지 프로토콜이기에** 메시지 Payload에는 **`Text`**나 **`Binary`**  데이터를 포함한다.

또한 양방향 네트워크 프로토콜 기반으로 동작을 **`발행-구독 패턴`**을 이용하여 진행한다.

그렇기 떄문에 기본적인 구조를 가장 많이 사용되는 예시 중 하나인 채팅방에 비유해 publisher, subscriber 개념을 살펴보자

1. 채팅방 생성 : pub / sub 구현을 위한 Topic이 생성됨
2. 채팅방 입장 : Topic 구독
3. 채팅방에서 메세지를 송수신 : 해당 Topic으로 메세지를 송신(pub), 메세지를 수신(sub)

이 일련의 과정이 발생될 때에는 아래와 같은 부가 정보들을 Client에서 메시지 브로커 (Spring Default Broker는 Stomp Broker)가 이를 받아 처리하게된다.

- Command 정보(Send, Subscribe 등)
- Header
- Message
- Message Channel 정보

그리고 모든 구독과 전송은 TOPIC을 기반으로 독립적으로 처리된다.

WebSocket 서버는 비동기 이벤트 루프를 사용하여 다수의 클라이언트 연결을 동시에 처리한다.

또한 TOPIC은 각각의 경로를 가진다고 생각하면 편하다.

### **결론**

STOMP를 사용하는 WebSocket 서버는 비동기 이벤트 루프와 메시지 브로커를 활용하여 각 **`TOPIC`**의 메시지를 독립적으로 비동기적으로 처리한다.

이를 통해서 각 방의 메시지가 서로 간섭 없이 빠르고 효율적으로 전달된다.
# 병행제어 (동시 공용)

**병행제어란?**

트랜잭션이 다중으로 실행 될때 DB의 일관성을 해치지 않는 선에서 트랜잭션을 제어하는 것을 말한다.

## 병행제어의 목적
시스템활용도의 최대화와 데이터베이스의 일관성유지와 사용자 응답시간의 단축에 목적을 두고 있다.

## 트랜잭션 동시 실행 시나리오
- Dirty Write : 같은 데이터에 대해 동시에 두개 이상의 트랜잭션이 값을 수정하려고 할때
- Dirty Read: 아직 Commit 되지 않은 트랜잭션의 쓰기 내용을 읽는 것으로 비정상적 상태의 데이터를 읽게 되는 현상
- Non-repeatable Read : 어떤 트랜잭션에서 동일한 데이터의 값을 매번 읽을 
- Phantom Read : 기존 데이터는 동일한 데 새로 추가된 값에 의해 데이터 값이 변경되는 현상

## 병행제어의 필요성
### 1. 갱신 분실
A 트랜잭션과 B 트랜잭션이 존재한다고 가정하였을 때, 둘다 동시에 하나의 회원정보에 갱신작업을 수행할 때, 하나의 갱신작업이 분실되는 경우


3. **모순성** : 한 개의 트랜잭션 작업이 갱신 작업을 하고 있는 상태에서 또 하나의 트랜잭션이 같은 작업 구역에 침범하여 작업하게 되어 데이터베이스의 일관성을 해치는 경우
4. **연쇄 복귀** : 같은 자원을 사용하는 두개의 트랜잭션 중 한개의 트랜잭션이 성공적으로 일을 수행하였다 하더라도 다른 트랜잭션이 처리하는 과정에서 실패하게되면, 다시 롤백되는 현상
5. **비완료 의존성** : 한 개의 트랜잭션이 수행과정에서 실패하였을 때, 이 트랜잭션이 회복되기전에 다른 트랜잭션 수행 결과를 참조하는 현상

# 병행제어 기법

## 1. 로킹(Locking)
트랜잭션이 어떤 데이터에 접근하고자 할 때 `로킹`을 수행한다.

**로킹을 한 트랜잭션만**이 로킹을 해제 할 수 있다. 즉, 로킹이 되어있는 데이터에는 다른 트랜잭션이 접근할 수 없다.

트랜잭션은 로킹이 된 데이터에 한해서만 연산을 수행하며, 로킹의 단위로는 필드,레코드,파일,데이터베이스 모두 로킹의 대상이 될 수 있음

- **로킹의 단위가 크면** : ex) 데이터베이스,페이지 단위
  - **장점**
    - 로킹 단위가 크기 때문에 오버헤드가 적다.
    - 동시 작업을 수행하는 트랜잭션 간의 **충돌 가능성**이 줄어들어 충돌 방지
    - 위와 같은 이유로 교차 점유로 인해 발생하는 **데드락** 가능성이 줄어듬
  - **단점**
    - 로킹단위가 크면 여러 트랜잭션이 하나의 잠금을 경합하는 상황이 더 자주 발생할 수 있다.
      - 예를 들어, 페이지 단위로 로킹을 설정한 경우에는 페이지에 속한 여러 행이 동시에 접근 제한을 받게 된다. 이로 인해 여러 트랜잭션이 대기해야 하는 경우가 증가하여 성능 저하가 발생할 수 있다.
    - 동시성이 제한된다.
      - 여러 트랜잭션이 동시에 작업할 수 있는 범위가 제한된다.
  
- **로킹의 단위가 작은 경우**
  - **장점**
    - 로킹의 동시성 수준이 높아진다.
  - **단점**
    - 그에 따라 관리가 어려워진다.

### 2단계 로킹 규약(Two-Phase Locking Protocol)

Lock과 Unlock이 동시에 이루어지면 일관성이 보장되지 않으므로 Lock만 가능한 단계와 Unlock만 가능한 단계를 구분하며 직렬가능성을 보장함, 하지만 교착상태가 발생할 수 있음.

**확장단계**
- 트랜잭션이 데이터를 읽기 위해 해당 데이터에 **공유 잠금**(Shared Lock)을 요청한다. 
  - 공유 잠금은 읽기만 허용하고 수정은 제한하는 것을 말한다.
- 트랜잭션이 데이터를 수정하기 위해 데이터에 **배타적 잠금**(Exclusive Lock)을 요청한다.
  - 배타적 잠금이란 읽기와 수정을 모두 제한한다.
- 공유 잠금은 여러 트랜잭션이 동시에 사용할 수 있지만, 배타적 잠금은 한 번에 하나의 트랜잭션만 사용할 수 있다.

이러한 Lock의 선택은 트랜잭션의 작업 종류에 따라 달라진다.

단순 조회작업이라면 공유 잠금을 수행하며, 수정 / 읽기 작업의 경우 배타적 잠금을 수행한다.

추가적으로, 2단계 로킹 규약에 따르는 트랜잭션은 한 번 배타적 잠금을 요청한 후에는 다시 공유 잠금을 요청하지 않는다.

이는 로킹을 획득한 후에는 트랜잭션이 계속해서 데이터를 읽고 수정할 수 있지만, 추가적인 잠금을 요청할 수는 없게 하기 위함이다.

이를 통해 상호 배제와 교착 상태 방지를 보장합니다.

**즉, 확장단계는** 트랜잭션에서 Lock만 일어나고 Unlock은 일어나지 않는다.

**축소 단계**
- 트랜잭션에서 데이터 사용이 모두 완료되면, 배타적 잠금을 해제한다.
  - 모든 데이터에 대해서 잠금을 해제하고 작업이 완료된다고 생각하면 된다.

### 2단계 로킹 규약의 목적

- **상호 배제** (Mutual Exclusion): 트랜잭션들이 동시에 데이터를 수정하는 것을 방지하여 데이터의 일관성을 보장한다.
- **교착 상태 방지** (Deadlock Prevention): 트랜잭션은 잠금을 요청할 때 순서를 지켜야 하며, 모든 잠금 요청은 이후에 잠금 해제가 이루어져야 한다. 이를 통해 교착 상태를 예방.
- **일관성 유지** (Consistency Preservation): 트랜잭션이 데이터를 읽거나 수정하는 동안 해당 데이터에 대한 잠금을 설정하여 일관성을 유지.
- **직렬화 가능성** (Serializability): 2단계 로킹 규약을 따르는 트랜잭션들은 직렬화 가능한 스케줄을 생성하므로, 트랜잭션의 동시 실행이 순차 실행과 동등한 결과를 보장.

## 2. 타임스탬프(Time Stamp)
데이터에 접근하는 시간을 미리 정하여 정해진 시간의 순서대로 데이터에 접근하며 수행함, 직렬가능성을 보장하며 시간을 나눠 사용하기 때문에 교착상태가 발생하지 않음, 하지만 연쇄복귀를 초래할 수 있음.

## 3. 낙관적 병행제어(Optimistic Concurrency Control)
트랜잭션 수행 동안은 어떠한 검사도 하지 않고, 트랜잭션 종료 시에 일괄적으로 검사를 수행한다.

트랜잭션 수행 동안 그 트랜잭션을 위해 유지되는 데이터 항목의 사본에 대해서만 갱신작업을 수행하며 트랜잭션 종료 시에 동시성을 위한 트랜잭션 직렬화가 검증되면 일시에 DB로 반영한다.

즉 트랜잭션들이 충돌하지 않고 동시에 실행될 수 있다고 가정한 후, 수행이 끝나면 충돌 여부를 확인하는 방식

### 낙관적 병행제어의 수행방식
- **읽기 단계** (Read Phase)
  - 트랜잭션이 데이터를 읽을 때는 로킹이나 잠금을 설정하지 않는다.
  - 트랜잭션은 읽기를 수행하고 필요한 데이터를 로컬 버퍼에 저장.

- **검증 단계** (Validation Phase)
  - 트랜잭션이 작업을 완료하고 커밋을 시도하기 전에 충돌 검증을 수행.
  - 검증 단계에서는 다른 트랜잭션들이 커밋했는지 여부와 충돌이 발생했는지를 확인.
  - 만약 충돌이 감지되면 트랜잭션은 롤백. 

- **쓰기 단계** (Write Phase)
  - 검증 단계를 통과한 트랜잭션을 실제 데이터로서 수정하고 커밋하는 단계.
  - 이때 다른 트랜잭션들은 해당 데이터를 읽으려고 시도하면 잠금 충돌을 확인하고 필요한 조치를 취한다.

낙관적 병행제어 방식의 장점으로는 충돌을 최소화하여 교착 상태를 없애고 성능을 개선한다는점에 있지만, 그에 따라 롤백이 잦을 수 있는 환경

## 4. 다중 버전 병행제어(Multi-version Concurrency Control)
하나의 데이터 아이템에 대해 여러 버전의 값을 유지하며 조회성능을 최대한 유지하기 위한 기법, 트랜잭션 간의 충돌 문제는 대기가 아니라 복귀처리 함으로 연쇄복귀초래 발생 가능성이 있음
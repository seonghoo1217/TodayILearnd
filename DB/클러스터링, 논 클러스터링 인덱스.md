인덱스를 생성하면 인덱스를 위한 디스크 공간이 필요하고, 인덱스를 가진 테이블에 DML 작업을 할 경우 더 많은 비용과 시간이 든다.

그렇기에 테이블에 맞는 인덱싱 전략을 위해 적절한 칼럼으로 **Clustered Index와 Non Clustered Index**를 구성한다.

## 클러스터 인덱스(Clustered Index)
![](https://velog.velcdn.com/images/sweet_sumin/post/6c154ac2-71bd-4316-a998-7c7c29157d27/image.png)

- Clustered Index를 구성하기 위해서 행 데이터를 해당 열로 정렬한 후에, 루트 페이지를 만들게 된다. (물리적으로 행을 재배열)
- 클러스터 인덱스는 대표적으로 테이블 당 1개씩만 허용된다.(Default. PK)
- 클러스터 인덱스는 트리형태로 저장되어, Root페이지와 Leaf페이지로 구성된다.
  - Root페이지는 Leaf페이지의 주소로 구성하고, Leaf페이지는 실제 데이터 페이지로 구성된다. 따로 추가적인 저장소에 인덱스 페이지를 만들지 않는다.
- 클러스터 인덱스 순서대로 실제 하드에 저장이된다.
  - 테이블 생성 시 Primary Key(PK)를 지정하면, 그 칼럼은 자동으로 Clustered Index가 만들어진다.
- MySQL의 InnoDB 스토리지 엔진에서는 기본적으로 Primary Key에 클러스터 인덱스를 생성한다. 
만약 Primary Key가 명시적으로 정의되지 않은 테이블이라면, InnoDB는 자동으로 고유 식별자를 생성하여 이를 클러스터 인덱스로 사용한다.
- 데이터 입력, 수정, 삭제 시 항상 정렬 상태를 유지한다.
  - 그렇기 떄문에 일반적으로 조회가 논 클러스터 인덱스에 비해 빠를 수 밖에 없다.
- 데이터 검색 순서 : 루트페이지 > 리프페이지(데이터 페이지)

📚어떤 경우에 생성해야할까?
테이블 데이터가 자주 업데이트 되지 않는 경우
MAX, MIN, COUNT등의 쿼리로 범위 또는 Group By 등의 조회를 하는 경우
항상 정렬 된 방식으로 데이터를 반환해야하는 경우
테이블은 정렬되어있기 때문에 ORDER BY 절을 활용해 모든 테이블 데이터를 스캔하지 않고 원하는 데이터를 조회할 수 있다.
읽기 작업이 월등히 많은 경우, 이때 매우 빠르다.
📚단점
리프 페이지가 모두 차있는데 새로운 데이터가 추가될때 페이지 분할이 일어난다.
→ 인덱스는 Balancing - Tree구조이기 때문에 기본적으로 모두 같은 크기의 페이지를 유지한다. 그래서 새로운 데이터가 추가되면 새로운 데이터가 추가 될 테이블의 기존 데이터 절반이 새로운 페이지로 이동한 후에 새로운 행이 추가된다. 이와 같이, 인덱스를 생성/수정/삭제할 때 페이지 분할이 일어나며 데이터 페이지 전체를 다시 정렬해야 하기 때문에 느려진다.
항상 순서를 유지해야 한다.
📖넌 클러스터 인덱스(Non Clustered Index)


출처) https://gwang920.github.io/database/clusterednonclustered/

레코드의 원본은 정렬되지 않고, 인덱스 페이지만 정렬된다. 즉, Non-Clustered Index는 데이터 페이지를 건드리지 않고, 별도의 장소에 인덱스 페이지를 생성
한다.
인덱스 페이지의 리프 페이지에 Index로 구성한 열을 정렬한 후 위치 포인터(RID)를 생성한다. 즉, Non-Clustered Index의 인덱스 페이지(리프 페이지)는 키값과 데이터가 위치하는 포인터(RID)로 구성된다.
포인터(RID): '파일그룹번호+데이터페이지 번호 + 페이지 내의 로우 번호'으로 구성되는 포인팅 정보.

인덱스를 생성할 때 데이터 페이지는 그냥 둔 상태에서 별도의 인덱스 페이지를 따로 만들기 때문에 용량을 더 차지한다.
테이블당 약 240개의 Non Clustered Index를 만들 수 있다.
클러스터형보다 검색 속도는 더 느리지만 데이터의 입력, 수정, 삭제는 더 빠르다.
→ 클러스터드 인덱스보다 페이지 분할이 적게 일어난다.
🌟데이터 검색 순서 : 루트페이지 > 리프페이지 > 데이터 페이지 (Heap page)
리프페이지가 모두 차 있어도 페이지 분할은 일어나지 않는다.
📚어떤 경우에 생성해야할까?
where절이나 Join 절과 같이 조건문을 활용하여 테이블을 필터링 하고자 할 경우
데이터가 자주 업데이트 될 경우
특정 컬럼이 쿼리에서 자주 사용 될 경우
📚단점
클러스터 인덱스는 테이블 정렬만 하면 되니 추가적인 저장공간이 필요없지만, 넌클러스터 인덱스는 인덱스 페이지만을 위한 추가 저장공간이 필요하다.
→ 데이터 삽입시 넌클러스터 인덱스는 별도의 공간에 인덱스를 생성해야하기 때문에 추가작업이 필요하다.
넌클러스터 인덱스는 데이터 접근 속도가 클러스터 인덱스보다 상대적으로 느리다.
인덱스 조회 시 비용이 많이 발생한다. (거쳐야 하는 단계가 많다)
→ 검색하고자하는 데이터의 키 값을 루트 페이지에서 비교하여 리프 페이지 번호를 찾고, 리프 페이지에서 RID 정보로 실제 데이터의 위치로 이동
클러스터 인덱스의 변경이 발생할 때 그에 상응하는 업데이트가 발생한다.
📖비교


> 본 포스팅은 트랜잭션 스케쥴링에 대한 정리 글이지만,
> 
> 기초적인 트랜잭션 개념과 회복에 대한 이해가 동반되어야한다.

# 트랜잭션

트랜잭션은 데이터베이스의 상태를 변화시키기 위한 `작업 수행의 논리적인 단위`를 말한다.

쉽게 말하자면 개발자가 SQL 쿼리를 사용하여 데이터베이스에 상태 변화를 일으킨다. 

이때 작업 단위는 **SQL 한개 일 수도 있고, SQL 작업을 묶은 단위**를 의미한다.


## 트랜잭션의 중요성
예를 들어 현재 배달의 민족 서비스를 예시로 들어보자

**A 트랜잭션**은 고객이 가게에 주문을 하는 작업이고, **B 트랜잭션**은 주문이 넘어왔을 때 배달쪽으로 넘기는 시스템이라고 가정해보자.

**그리고 A 로직을 수행하던 도중 서버에 예기치 못한 에러가 발생한다면 어떻게 될까?**

A 로직에서 주문을 접수하였지만 에러가 발생하여, A 로직은 Rollback 되었고 B 로직에는 주문이 전달되게 된다.

이후 고객의 변심으로 인해 주문을 다시 재접수하지 않거나 재접수하더라도 중복이 일어나기에 가게 쪽에서는 난감한 상황을 겪게 되는것이다.

이러한 문제들을 사전에 방지하고자 **주문-접수** 과정 자체를 하나의 `트랜잭션(Transaction)`으로 묶어 로직을 수행시켜야한다.

이처럼 작업 단위를 잘 설정하는 것은 서비스를 구성함에 있어서 매우 중요한 부분이다. 트랜젝션이 성공적으로 마무리 되었다면 commit을 호출해서 수정 사항을 DB에 영구적으로 반영하고,
중간에 오류가 발생했다면 rollback을 호출해서 트랜젝션 내부의 모든 작업을 원상복구 시킨다.

## 트랜잭션의 특성
트랜젝션은 ACID라는 4가지의 특성이 존재한다.

### 원자성(Automicity)
트랜젝션 내부에서 실행된 작업들이 모두 성공해서 commit이 되거나, 문제가 발생한다면 rollback을 통해 모두 취소되야 한다.
일부만 성공하고, 일부만 실패하는 구조가 되지 못한다는 것이다.

즉, 위의 예시와 같이 하나의 트랜잭션이라는 단위로 작업의 수행이 일관되어야한다.

**원자성 보장**
트랜젝션 내에서 데이터베이스를 수정할때 지금까지의 성공 내역이 롤백 이미지로 롤백 세그먼트라는 임시 영역에 저장 된다.
그렇기에 장애를 겪더라도 롤백 세그먼트 내의 상태로 Rollback하여 상태를 복구 할 수 있다.

하지만 트랜잭션이 문제 없이 로직을 수행하였다면, Commit 후에 DB에 수정사항이 영구적으로 반영되어 롤백 세그먼트의 롤백 이미지도 날라간다.

**Save Point**
Save Point란 개념은, ORM을 이용해 개발을 해오던 나에겐 생소한 개념이었다.

예를 들어 트랜잭션에 마지막 부분에 문제가 발생하였다고 가정을 해보자. 그렇다면 문제가 발생하였기 때문에 롤백을 실행하여야하는데
문제가 발생하지 않는 영역까지 반복적으로 수행하는 것이 과연 효율적일까?

그렇지 않다. 그렇기 때문에 우리는 **`Save Point`**를 지정해줄 필요가 있는 것이다.

savePoint는 트랜젝션 내부에서 사용자가 지정할 수 있는 세부 작업 단위라고 생각하면된다.
이후 Rollback을 수행해야 할 때 마다 지점으로 설정한 Save Point로 롤백을 시킬 수있다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbZAlvz%2Fbtrpgzeqiin%2FgbfmebyddSKi9hKGRSeJR1%2Fimg.png)

다만, 위 그림과 같이 SP1 시점으로 롤백할 경우 미래 시점인 SP2는 삭제된다.

### 일관성(Consistency)
모든 트랜젝션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 멱등성과 완전유사는 아니지만 비슷한 개념이다.

트랜젝션 전 후의 데이터베이스의 상태가 Correct State여야 한다고 하는데, Correct State는 도메인의 유효범위, 
무결성 제약조건 등의 제약조건을 위배하지 않는 정상적인 상태를 의미한다.

예를 들어 데이터 타입이 정수형이라면 트랜젝션 이후에도 정수형으로 유지되어야 하며, null값을 제한해놓은 컬럼에 null값이 들어가 있으면 안된다. 
또한 연관관계에서 변경이 일어났으면 외래키 값도 정상적으로 변경되어야 한다. 이런 제약조건을 변함없이 만족해야 일관성을 유지했다고 말할 수 있다.

### 격리성(Isolation)
각 트랜잭션은 서로 간의 영향을 끼쳐선 안된다.

예를 들어 회원의 이름을 바꾸는 트랜잭션과 회원의 거주지를 바꾸는 트랜잭션이 별도로 존재한다고 가정해보자.

```markdown
name : LEE,
address : Seoul,
age: 25
.
.
.
```
원 Entity가 저렇게 구성되어있다고 가정하였을 때, 회원의 이름을 바꾸는 트랜잭션과 회원의 거주지를 각각 `Park`과 `Hanam`으로 변경할때
서로 간섭이 된다면 **[Park,Seoul]**이 되거나 **[LEE,Hanam]**으로 변경되어 옳바르게 수정작업이 완료되지 못할 수 있다.

그렇기에 각 트랜잭션에 격리성을 완전히 보장하기 위해서 각각의 트랜잭션이 순차적으로 수행되어야한다.

하지만 이는 동시성 처리 부분에서 안좋은 성능을 보인다. 따라서 격리성의 수준을 여러 단계로 나눠놓았다.

### READ UNCOMMITED
상대방에 커밋하지 않은 데이터를 읽을 수 있다.
예를 들어 사용자 A가 트랜젝션 내에서 데이터를 수정하고 있는데 사용자 B가 그 데이터를 조회할 수 있다.

이렇듯 커밋되지 않은 데이터를 조회하는걸 `Dirty Read`라고 말한다. 

사용자 B가 데이터를 사용하는 도중에 사용자A가 데이터를 롤백시켜 버리면 **데이터 정합성**(B가 사용하는 데이터와 A가 가지고있는 데이터의 차이가 발생)이 깨질 수 있다.



### READ COMMITED
상대방이 커밋한 데이터만 조회할 수 있다. 따라서 Dirty Read는 발생하지 않는다.

하지만 `NON-REPEATABLE READ`가 발생할 수 있다. 

예를 들어 사용자A가 커밋한 데이터를 사용자B가 트랜젝션 내에서 조회하고 있는데 이후에 사용자 A가 데이터를 수정 후 다시 커밋한다면 사용자B는 같은 트랜젝션 내에서 다른 데이터를 조회하게 되는 것이다.



### REPEATABLE READ
한번 조회한 데이터는 트랜젝션 내에서 다시 조회해도 같은 데이터가 나오는게 보장된다.(NON-REPETABLE READ가 발생하지 않음)

하지만 `PHANTOM READ`가 발생할 수 있다.

예를 들어 사용자A가 트랜젝션 내에서 20살 이하의 회원 리스트를 조회했을때, 중간에 사용자B가 회원을 20살 이하 회원을 한명 추가한다면, 다시 리스트를 조회했을때 나오는 결과가 달라질 수 있다.

이처럼 결과 집합이 달라지는 것을 **PHANTOM READ**라고 한다.

### SERIALABLE
가장 엄격한 수준의 격리성이지만 동시성 처리에는 매우 약하다.

데이터베이스들은 보통 동시성 처리가 중요하기 때문에 READ COMMITED 수준의 격리성을 사용한다.

## 지속성(Durability)
성공적으로 수행된 트랜잭션은 기록으로 남아 저장되며, 복구에도 사용된다.


# 트랜잭션의 상태
- 활동(active) : 트랜잭션이 수행되기 시작하여 현재 수행중인 상태
- 부분완료(partially committed) : 트랜잭션의 마지막 연산이 실행을 끝낸 직후의 상태
- 완료(commited) : 트랜잭션이 성공적으로 완료되어 commit 연산 실행한 상태, 트랜잭션이 수행한 최종 결과를 데이터베이스에 반영하고, 데이터베이스가 새로운 일관된 상태가 되면서 트랜잭션이 종료
- 실패 (failed) 상태: 장애가 발생하여 트랜잭션이 중단된 상태
- 철회 (aborted) 상태 : 트랜잭션 수행이 실패하여 rollback연산을 통해 이전 커밋 상태로 돌아간 상태. 

# 트랜잭션 장애와 회복

**장애의 정의란?** 시스템이 제대로 동작하지 않아 트랜잭션의 작업이 원활히 이루어질 수 없는 상태

하지만, 트랜잭션에서의 장애는 대표적으로 세 가지 종류가 존재한다.

첫 번째로는, 트랜잭션 장애이다. 이는 말그대로 트랜잭션 연산 도중 수행할 수 없는 에러를 만나 일어나는 에러를 뜻한다.

트랜잭션의 논리적 오류. 잘못된 데이터 입력, 시스템 자원의 과돠 사용 요구, 처리 대상 데이터의 부재가 주원인이 된다.

두번째로는 하드웨어의 결함이 문제를 유발할 수 있다.

세번째로는 데이터베이스의 일부 또는 전체가 손상된 상태일 수 있다.

## 트랜잭션 수행시 메모리 이동 연산
![](https://blog.kakaocdn.net/dn/viTYu/btrjV9Sqznm/KMeERbTBn4paoTwn8UUkH1/img.png)

일반적인 경우 데이터베이스는 디스크에 상주하며, 트랜잭션이 데이터베이스에 연산을 수행하기 위해선 디스크에서 메인 메모리로 데이터를 가져와
처리후 결과를 다시 디스크로 전달하는 번거로움이 존재한다.

디스크와 메모리간의 데이터 이동은 블록단위(디스크 블록, 버퍼 블록)로 수행되며, Input과 Output 연산의 묶음으로 수행된다.

- input(X): 디스크 블록에 저장되어 있는 데이터 X를 메인 메모리 버퍼 블록으로 이동시키는 연산
- output(X): 메인 메모리 버퍼 블록에 있는 데이터 X를 디스크 블록으로 이동시키는 연산

또한, 사용자의 요구에 따라 응용프로그램에서 트랜잭션의 수행을 지시하면 메인 메모리 버퍼 블록에 있는 데이터를 프로그램의 변수로 가져오고, 데이터 처리 결과를 저장한 변수 값을 메인 메모리 버퍼 블록으로 옮기는 작업이 필요하다.

메인 메모리의 버퍼 블록과 프로그램 변수간의 데이터 이동은 아래의 두 연산이 필요하다.

- read(X): 메인 메모리 버퍼 블록에 저장되어 있는 데이터 X를 프로그램의 변수로 읽어오는 연산
- write(X): 프로그램의 변수 값을 메인 메모리 버퍼 블록에 있는 데이터 X에 기록하는 연산

## 회복
- 장애가 발생했을 때 데이터베이스를 장애가 발생하기 전의 일관된 상태로 복구시키는 것
- 트랜잭션의 특성 보장 + 데이터베이스를 일관된 상태로 유지하기 위해 필수
- 회복 관리자가 담당: 장애 발생을 탐지하고, 장애가 탐지되면 데이터베이스 복구 기능 제공

### 회복 연산
회복은 데이터베이스에 장애가 발생했을 때 장애가 발생하기 전의 일관된 상태로 복구시키는 것으로, 데이터베이스 관리 시스템의 회복 관리자가 담당한다.
장애가 탐지되면 데이터베이스 복구 기능을 사용한다.
데이터베이스를 복구하는 동안 데이터베이스에 접근하여 업무를 처리할 수 없어서, 회복 작업은 빠른 시간내에 이루어져야 한다.

회복은 대표적으로 데이터의 복사를 통해 쉽게 사용한다.

별도의 장소에 미리 복사해두고, 장애가 발생시 복사본을 이용해 원래의 상태로 복원하는 방법을 사용한다.

데이터의 복사 방법은 두가지가 있다.

1. 덤프(dump) : 데이터 베이스 전체를 다른 저장 장치에 주기적으로 복사하는 방법

2. 로그(log) : 데이터베이스에서 변경 연산이 실행될 때마다 데이터를 변경하기 이전 값과 변경한 이후의 값을 별도의 파일에 기록하는 방법

장애가 발생했을 때, 덤프나 로그 방법으로 중복 저장한 데이터를 이용해 데이터베이스를 복구하는 기본적인 방법으로는 redo연산과, undo연산이 있다.

- redo(재실행)
    - 가장 최근에 저장한 데이터베이스 복사본을 가져온 후 로그를 이용해 복사본이 만들어진 이후에 실행된 모든 변경 연산을 재실행하여 장애가 발생하기 직전의 데이터베이스 상태로 복구
    - 손실시에 많이 사용
- undo(취소)
    - 로그를 이용해 지금까지 실행된 변경 연산을 취소하는 것
    - 원래의 데이터베이스 상태로 복구

## 회복기법
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FqFAUt%2FbtrjWSiawaF%2FVWOHl451AVumyiiI9Bgtw1%2Fimg.png)

### 로그 회복 기법 - 즉시 갱신 회복 기법
- 트랜잭션 수행 중에 데이터 변경 연산의 결과를 데이터베이스에 즉시 반영
- 장애 발생에 대비하기 위해 데이터 변경에 대한 내용을 로그 파일에 기록, 데이터 변경 연산이 실행되면 로그 파일에 로그 레코드를 먼저 기록한 다음 데이터베이스에 변경 연산 반영
- 장애 발생 시점에 따라 redo나 undo 연산 실행해 데이터베이스 복구

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F4TkeO%2FbtrjWnwfguN%2FakA281l2cSvxeSAhRQLr4k%2Fimg.png)
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FNDpoZ%2Fbtrj0WKTSrR%2Fjhp80BHzwczYTBVB0Kx6Xk%2Fimg.png)
### 로그 회복 기법 - 지연 갱신 회복 기법

- 트랜잭션 수행 중에 데이터 변경 연산의 결과를 로그에만 기록해두고, 트랜잭션이 부분 완료된 후에 로그에 기록된 내용을 이용해 데이터베이스에 한 번에 반영
- undo 연산 필요 없고 redo 연산만 사용
- 로그 레코드에는 변경 이후 값만 기록하면 됨 : <T1, X, new_value> 형식

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F6MTkE%2FbtrjXC7vBGI%2FSW89v8LVkBeD1e0Jnsasok%2Fimg.png)
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbVXIaV%2Fbtrj0LbzUW5%2FtW1AtHpgZkkHvqcRt3rIL0%2Fimg.png)

### 검사 시점 회복 기법
- 로그 기록 이용하되, 일정 시간 간격으로 **검사 시점(checkpoint)**를 만듦
- 장애 발생 시 가장 **최근 검사 시점 이후의 트랜잭션에만 회복 작업** 수행
- 로그 전체를 대상으로 회복 기법을 적용할 때 발생할 수 있는 비효율성의 문제를 해결

### 미디어 회복 기법
- 디스크에 발생할 수 있는 장애에 대비한 회복 기법
- 덤프(복사본) 이용: 전체 데이터베이스의 내용을 일정 주기마다 다른 안전한 저장 장치에 복사
- 디스크 장애 발생하면, 가장 최근에 복사해둔 덤프를 이용해 장애 발생 이전의 데이터베이스 상태로 복구하고 필요에 따라 redo 연산 수행

## 트랜잭션 스케줄(Transaction Schedule)

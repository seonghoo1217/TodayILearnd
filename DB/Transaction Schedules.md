> 본 포스팅은 트랜잭션 스케쥴링에 대한 정리 글이지만,
> 
> 기초적인 트랜잭션 개념과 회복에 대한 이해가 동반되어야한다.

# 트랜잭션

트랜잭션은 데이터베이스의 상태를 변화시키기 위한 `작업 수행의 논리적인 단위`를 말한다.

쉽게 말하자면 개발자가 SQL 쿼리를 사용하여 데이터베이스에 상태 변화를 일으킨다. 

이때 작업 단위는 **SQL 한개 일 수도 있고, SQL 작업을 묶은 단위**를 의미한다.


## 트랜잭션의 중요성
예를 들어 현재 배달의 민족 서비스를 예시로 들어보자

**A 트랜잭션**은 고객이 가게에 주문을 하는 작업이고, **B 트랜잭션**은 주문이 넘어왔을 때 배달쪽으로 넘기는 시스템이라고 가정해보자.

**그리고 A 로직을 수행하던 도중 서버에 예기치 못한 에러가 발생한다면 어떻게 될까?**

A 로직에서 주문을 접수하였지만 에러가 발생하여, A 로직은 Rollback 되었고 B 로직에는 주문이 전달되게 된다.

이후 고객의 변심으로 인해 주문을 다시 재접수하지 않거나 재접수하더라도 중복이 일어나기에 가게 쪽에서는 난감한 상황을 겪게 되는것이다.

이러한 문제들을 사전에 방지하고자 **주문-접수** 과정 자체를 하나의 `트랜잭션(Transaction)`으로 묶어 로직을 수행시켜야한다.

이처럼 작업 단위를 잘 설정하는 것은 서비스를 구성함에 있어서 매우 중요한 부분이다. 트랜젝션이 성공적으로 마무리 되었다면 commit을 호출해서 수정 사항을 DB에 영구적으로 반영하고,
중간에 오류가 발생했다면 rollback을 호출해서 트랜젝션 내부의 모든 작업을 원상복구 시킨다.

## 트랜잭션의 특성
트랜젝션은 ACID라는 4가지의 특성이 존재한다.

### 원자성(Automicity)
트랜젝션 내부에서 실행된 작업들이 모두 성공해서 commit이 되거나, 문제가 발생한다면 rollback을 통해 모두 취소되야 한다.
일부만 성공하고, 일부만 실패하는 구조가 되지 못한다는 것이다.

즉, 위의 예시와 같이 하나의 트랜잭션이라는 단위로 작업의 수행이 일관되어야한다.

**원자성 보장**
트랜젝션 내에서 데이터베이스를 수정할때 지금까지의 성공 내역이 롤백 이미지로 롤백 세그먼트라는 임시 영역에 저장 된다.
그렇기에 장애를 겪더라도 롤백 세그먼트 내의 상태로 Rollback하여 상태를 복구 할 수 있다.

하지만 트랜잭션이 문제 없이 로직을 수행하였다면, Commit 후에 DB에 수정사항이 영구적으로 반영되어 롤백 세그먼트의 롤백 이미지도 날라간다.

**Save Point**
Save Point란 개념은, ORM을 이용해 개발을 해오던 나에겐 생소한 개념이었다.

예를 들어 트랜잭션에 마지막 부분에 문제가 발생하였다고 가정을 해보자. 그렇다면 문제가 발생하였기 때문에 롤백을 실행하여야하는데
문제가 발생하지 않는 영역까지 반복적으로 수행하는 것이 과연 효율적일까?

그렇지 않다. 그렇기 때문에 우리는 **`Save Point`**를 지정해줄 필요가 있는 것이다.

savePoint는 트랜젝션 내부에서 사용자가 지정할 수 있는 세부 작업 단위라고 생각하면된다.
이후 Rollback을 수행해야 할 때 마다 지점으로 설정한 Save Point로 롤백을 시킬 수있다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbZAlvz%2Fbtrpgzeqiin%2FgbfmebyddSKi9hKGRSeJR1%2Fimg.png)

다만, 위 그림과 같이 SP1 시점으로 롤백할 경우 미래 시점인 SP2는 삭제된다.

### 일관성(Consistency)
모든 트랜젝션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 멱등성과 완전유사는 아니지만 비슷한 개념이다.

트랜젝션 전 후의 데이터베이스의 상태가 Correct State여야 한다고 하는데, Correct State는 도메인의 유효범위, 
무결성 제약조건 등의 제약조건을 위배하지 않는 정상적인 상태를 의미한다.

예를 들어 데이터 타입이 정수형이라면 트랜젝션 이후에도 정수형으로 유지되어야 하며, null값을 제한해놓은 컬럼에 null값이 들어가 있으면 안된다. 
또한 연관관계에서 변경이 일어났으면 외래키 값도 정상적으로 변경되어야 한다. 이런 제약조건을 변함없이 만족해야 일관성을 유지했다고 말할 수 있다.

### 격리성(Isolation)
각 트랜잭션은 서로 간의 영향을 끼쳐선 안된다.

예를 들어 회원의 이름을 바꾸는 트랜잭션과 회원의 거주지를 바꾸는 트랜잭션이 별도로 존재한다고 가정해보자.

```markdown
name : LEE,
address : Seoul,
age: 25
.
.
.
```
원 Entity가 저렇게 구성되어있다고 가정하였을 때, 회원의 이름을 바꾸는 트랜잭션과 회원의 거주지를 각각 `Park`과 `Hanam`으로 변경할때
서로 간섭이 된다면 **[Park,Seoul]**이 되거나 **[LEE,Hanam]**으로 변경되어 옳바르게 수정작업이 완료되지 못할 수 있다.

그렇기에 각 트랜잭션에 격리성을 완전히 보장하기 위해서 각각의 트랜잭션이 순차적으로 수행되어야한다.

하지만 이는 동시성 처리 부분에서 안좋은 성능을 보인다. 따라서 격리성의 수준을 여러 단계로 나눠놓았다.

### READ UNCOMMITED
상대방에 커밋하지 않은 데이터를 읽을 수 있다.
예를 들어 사용자 A가 트랜젝션 내에서 데이터를 수정하고 있는데 사용자 B가 그 데이터를 조회할 수 있다.

이렇듯 커밋되지 않은 데이터를 조회하는걸 `Dirty Read`라고 말한다. 

사용자 B가 데이터를 사용하는 도중에 사용자A가 데이터를 롤백시켜 버리면 **데이터 정합성**(B가 사용하는 데이터와 A가 가지고있는 데이터의 차이가 발생)이 깨질 수 있다.



### READ COMMITED
상대방이 커밋한 데이터만 조회할 수 있다. 따라서 Dirty Read는 발생하지 않는다.

하지만 `NON-REPEATABLE READ`가 발생할 수 있다. 

예를 들어 사용자A가 커밋한 데이터를 사용자B가 트랜젝션 내에서 조회하고 있는데 이후에 사용자 A가 데이터를 수정 후 다시 커밋한다면 사용자B는 같은 트랜젝션 내에서 다른 데이터를 조회하게 되는 것이다.



### REPEATABLE READ
한번 조회한 데이터는 트랜젝션 내에서 다시 조회해도 같은 데이터가 나오는게 보장된다.(NON-REPETABLE READ가 발생하지 않음)

하지만 `PHANTOM READ`가 발생할 수 있다.

예를 들어 사용자A가 트랜젝션 내에서 20살 이하의 회원 리스트를 조회했을때, 중간에 사용자B가 회원을 20살 이하 회원을 한명 추가한다면, 다시 리스트를 조회했을때 나오는 결과가 달라질 수 있다.

이처럼 결과 집합이 달라지는 것을 **PHANTOM READ**라고 한다.

### SERIALABLE
가장 엄격한 수준의 격리성이지만 동시성 처리에는 매우 약하다.

데이터베이스들은 보통 동시성 처리가 중요하기 때문에 READ COMMITED 수준의 격리성을 사용한다.

## 지속성(Durability)
성공적으로 수행된 트랜잭션은 기록으로 남아 저장되며, 복구에도 사용된다.

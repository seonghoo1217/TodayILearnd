# 서킷 브레이크 패턴

## 등장
외부 API를 호출해야하는 경우 또는 MSA 환경에서 다른 서비스를 호출하는 경우 서버들에 장애가 발생할 수 있다는 점인데, 호출한 다른 서비스에 장애가 발생했다면 장애가 전파되어,
해당 서비스까지 문제가 발생할 수 있다. 또한 장애가 발생한 서버에 계속 요청을 보내는 것은 장애 복구를 힘들게 만든다

그래서 장애가 발생한 서비스를 탐지하고, 요청을 보내지 않도록 차단할 필요가 생기게되었다

즉, 서비스 장애를 탐지 및 차단하기 위한 패턴이 서킷 브레이크 패턴이다.

## 자세히 알아보기
외부 서비스에 의한 문제를 방지하기 위해 등장한 것이 서킷 브레이커 패턴이다.
문제가 발생한 지점을 감지하고 실패하는 요청을 계속하지 않도록 방지하는 것이 주 목표이다.

이를 통해 시스템의 장애 확산을 막고, 장애 복구를 도와주며 사용자는 불필요하게 대기하지 않게 된다.

즉, 서킷 브레이커 패턴은 **클라이언트 측면에서 장애를 방지하기 위한 도구**로써, 실패할 수 있는 **작업을 계속 시도하지 않도록 방지**한다.

## 서킷 브레이크 패턴 동작원리
목적은 최대한의 효율성이 아닌 문제를 차단하는 것에 있다.

### 서킷 브레이커의 3가지 상태
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FnLkKP%2FbtrFySvDCYD%2F772TLZzVC4avkjxnK10KA1%2Fimg.png)

해당 이미지에서 비유적으로 실제회로에 덧대어 설명할 때, 전구는 API, Power Source는 클라이언트(다른 서버를 호출하는 서버)에 해당하며,
회로 차단기에는 크게 Closed, Open, Half Open 3가지 상태가 존재한다.

네, 주어진 정보를 바탕으로 표를 만들어드리겠습니다.

| 상태       | 상황                                         | 요청                                                         | 상태 전이                                                   |
|-----------|------------------------------------------|--------------------------------------------------------|-------------------------------------------------------|
| Closed    | 모든 것이 정상인 상황                        | 외부(Callee)로의 요청을 차단하고 바로 에러를 받음                    | 외부(Callee)로의 요청을 차단하고 바로 에러를 받음                    |
| Open      | 외부(Callee)에 장애가 발생한 상황                | 외부(Callee)로의 요청을 차단하고 바로 에러를 받음                    | 특정 시간이 지나면 Half Open 상태가 됨                             |
| Half Open | Open 상태가 되고 일정 시간이 지난 상황 | 외부(Callee)로의 요청을 차단하고 바로 에러를 받음                    | 일부 허용된 요청들이 성공한 경우 Closed 상태로, 실패인 경우 Open 상태로 변경 |

**🤔 그럼 외부에서 장애가 일어났다고 판단하는 기준은 무엇일까?**
- slow call: 기준 시간보다 오래 걸린 요청
- failure call: 실패하거나 오류를 응답받은 요청

**🤔 그럼 이를 패턴적으로 어떻게 풀어낼 수 있을까?**
규칙을 만들어 장애의 기준을 만들면 된다.
예를 들어, 특정 **요청이 N번 연속 실패할 경우 요청을 차단** 하거나 특정 요청의 **RPS가 N초 이상 지연되는 경우** 또는 **차단된 요청이 N번 연속 성공 할 경우 요청을 전송**한다.

### 동작 방식 예시
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FkDJjc%2FbtrFAPR0yeK%2FViKuX93c6fd2yxtdhhAkjk%2Fimg.png)
1. 일반적으로 외부 서버는 정상 실행중이므로, 서킷이 닫혀있고 요청이 정상적으로 전달
2. 외부 서버에 장애가 발생함
3. 요청 지속적으로 실패시 서킷 Open
4. 이후의 요청들은 더 이상 전달되지 않고 차단 및 에러 응답 전달
5. 외부 서버 복구
6. 회로가 Open 상태가 된지 특정 시간이 지나고, Half Open 상태로 변경
7. 일부 요청들이 외부 서버로 전달되고, 응답에 성공하여 Closed
8. 모든 요청들이 정상적으로 전달됨

Open 상태가 되면 특정 시간이 지나야 Half Open 상태가 된다.

만약 **Half Open** 상태가 되었는데도 **외부 서버가 복구되되지 않았다면**, 요청들은 실패해서 다시 Open 상태로 변경될 수도 있다. 

여기서 중요한 것은 이러한 상태 변경이 자동으로 수행된다는 것이며, 상태 전이를 위한 시간들은 시스템 내부에서 관리되므로 대부분 타임아웃과 관련된 모니터링 시스템을 제공해준다.

## 서킷 브레이크 패턴의 장점 및 필요성
- 장애 감지 및 격리
- 자동 시스템 복구
- 빠른 실패 및 고객 응답
- 장애 서비스로의 부하 감소
- 장애 대안 커스터마이징

### 장애 감지 및 격리
장애가 발생한 리소스 호출 시 요청이 타임아웃만큼 대기하게 되고 쓰레드와 메모리 및 CPU 등의 자원을 점유하게 된다.

이는 결국 시스템 리소스를 부족하게 만들어 장애를 유발한다. 즉, 장애의 전파가 발생한다.

서킷 브레이커 패턴은 장애가 발생한 서비스를 감지하고, 더 이상 요청을 보내지 않도록 차단함으로써 장애를 격리시켜 시스템의 안정성을 높인다.

### 자동 시스템 복구
서킷 브레이커는 요청이 차단되면 해당 서비스가 정상인지 검사를 주기적으로 실행하며, 복구되었다면 차단이 해제되고, 정상적으로 요청을 보내게 된다

이러한 기능을 자동적으로 타임아웃 등을 위한 모니터링 기능까지 제공한다.

### 빠른 실패 및 고객 응답
다른 서비스가 문제있음을 알 수 있다면, 타임아웃 동안 기다리며 자원을 낭비할 필요가 없다.
그래서 빠르게 장애를 탐지하는 것이 중요한데, 서킷브레이커 패턴을 적용하면 가능한 빠르게 실패를 반환하고, 고객에게 응답을 전달할 수 있다.

### 장애 대안 커스터 마이징
외부 서비스에서 장애가 발생했다면 원하는 데이터를 얻지 못할 수 있다.
이때 아무런 대응책이 없다면 해당 서비스 역시 장애가 발생하게 된다.
서킷 브레이커를 적용하면, 장애 대안을 커스터마이징 할 수 있는데, 예를 들어 다른 소스로부터 값을 얻어오거나, 서킷 브레이커가 자체적으로 캐싱해 둔 값으로 응답하는 등 다양한 방법을 적용할 수 있다. 

그러면 외부에 장애가 발생해도 문제없이 서비스를 운영할 수도 있다.

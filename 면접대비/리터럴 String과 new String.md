![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/db74ba2d-24e4-4d4b-ae5c-07d99cd33ca1/ed947f6d-bc7e-49f6-9364-af8ceea80f04/image.png)

자바에서 문자열을 다루는 방법으로는 문자열 리터럴을 사용하는 방법과 새로운 객체를 생성하는 방법이 있다.

두 방법에는 문자 데이터를 다루는 방식에서 차이가 있다.

자바는 문자열 리터럴을 String Pool 내에 저장하고 동일한 문자열 리터럴에 대해서는 하나의 참조를 재사용하기 때문인데 예를들어 아래와 같은 코드가 있다고 생각해보자

```jsx
String str1 = "Hello";
String str2 = "Hello";
```

여기서 str1과 str2는 동일한 문자열 리터럴 "Hello"를 참조한다. 따라서 str1과 str2는 같은 메모리 주소를 가리키게 되기에 참조비교인 `==` 을 사용할 경우 이는 참이된다.

```jsx
System.out.println(str1 == str2); // true
```

그렇기에 String Pool에 저장되는 문자열 리터럴 방식은 동일한 문자열에 대해 재사용하기에 메모리 적으로 효율성이 높다.

참고로 String Pool은 **`Heap`** 영역에 해당된다.

## new String()

**`new String`**으로 새로운 String 객체를 만드는 방식도 Heap 영역을 이용하지만 동일한 문자열 값도 다른 객체로 인식하기 때문에 다른 메모리 주소를 가지게된다.

왜냐하면 **`new String()`**으로 생성된 문자열은 String Pool을 거치지 않고 직접 힙 영역에 저장되기 때문이다.

이로 인해 메모리 사용량이 늘어나고, 동일한 문자열이라도 각각의 객체로 관리된다.

## 성능

앞서 설명했듯 성능적인 측면에서 문자열 리터럴을 사용하는 것이 **`new String()`**을 사용하는 것보다 유리하다.

문자열 리터럴을 사용하면 String Pool에 의해 문자열이 재사용되므로, 메모리 할당과 가비지 컬렉션의 부담이 줄어들게된다.

즉, 오버헤드를 줄이기 때문에 더 효율적인거다.

## 비교 연산

String을 다루기 때문에 비교연산자도 한번 살펴보자면

**`==`** 은 객체의 주소값을 비교하는 반면, **`equals()`** 메소드는 문자열의 내용 자체를 비교한다.
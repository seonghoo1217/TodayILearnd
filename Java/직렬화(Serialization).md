## Serializable
직렬화를 위해 Class를 대상으로 `Serializable`을 implement하여 사용하는 것을 한번씩은 본적이 있을 것이다.

```java
public interface Serializable {

}
```

하지만, Serializable 인터페이스를 살펴보면, 메서드는 커녕 상속 관계조차 없다.

이 Serializable은 기본적으로 자바 시스템 내부에서 사용되는 기술이다.

그리고 자바는 객체단위의 프로그래밍을 지향하다보니 몇가지 경우를 마주하게된다.
1. Object를 파일로 변환하여 저장
2. 저장한 객체를 읽어들일 일이 생길 수도 있다.
3. 다른 서버에서 생성한 객체를 받을 일이 발생할 수도 있다.

> 정확히 설명하자면, Object 또는 Data를 외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터를 변환하는 기술.
> JVM의 메모리에 상주되어 있는 객체 데이터를 바이트 형태로 변환하는 기술이다.
>
> 이러한, 다차원의 자료를 파일로 저장하거나 네트워크로 보내기에 알맞게 일차원으로 펼치고 다시 원래대로 되돌리는 것(역직렬화)을 **직렬화(serialization)**라고 한다.
> 시스템적으로 이야기하자면 JVM(Java Virtual Machine 이하 JVM)의 메모리에 상주 (힙 또는 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술과 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태

## SerialVersionUID
- 대부분의 Collection Framework 또는 객체에서 별도의 `serialVersionUID` 값을 가지고 있다.
- 이것은 왜 필요한 것일까?
- 서버 분산시의 상황을 예시로 가정해보자
  - A라는 서버에서 B라는 서버로 SerialDTO라는 클래스의 객체를 전송한다고 가정하였을 때 두 서버에는 SerialDTO가 존재해야지 그 클래스의 객체임을 알고 데이터를 받을 수 있다.
  - 하지만 만약 A 서버가 갖고 있는 SerialDTO에는 변수가 3개 있고, B 서버의 SerialDTO에는 변수가 4개 있는 상황이라면 자바에서는 해당 객체가 같은 객체인지 검증할 방법이 업승ㅁ
  - 그렇기에 별도의 UID를 부여하여 관리 (버전이 바뀌면 객체의 상태가 조금이라도 바뀌었다는 것을 의미하고 결국 역직렬화 과정에서 오류가 발생)
x## 소개배경
Database에는 **관계 매핑**이 크게 3가지가 존재한다.

- **1:1**
- **1:N**
- **M:N**

이 중 다대다 관계를 포함한 형식을 **ORM**인 **JPA**에서는 Entity간에 **`Annotation`**형식으로 관계의 매핑을 도와준다.



하지만 **@OneToOne**과 **@OneToMany**(**@ManyToOne**)를 제외한 **`@ManyToMany`**를 사용할 경우 성능의 저하가 발생하는 이슈가 존재하였기에 이를 포스팅해보고자한다.

## 성능이 왜 떨어지나요?
자 우선적으로 우리는 @ManyToMany를 각 엔티티에 걸었을때 작동하는 원리를 알아야한다.

예를 들어, **회원**과 **칭호**라는 Entity가 각각 있다고 가정해보자.

이때 기능 요구사항은 회원은 여러 칭호를 수집할 수 있고, 같은 칭호를 여러 회원이 가질 수있을 때 아마 두 Entity의 관계는 **@ManyToMany**인 것이 가장 합당할 것이다.

하지만, 앞서 말했다시피 @ManyToMany를 쓰면 성능이 저하된다고 하였다. 이제부터 어떤 부분들이 저하되는건지 알아보자.

우선 **첫 번째**로 **추가적인 Join**이 발생한다.

ManyToMany의 경우 실제로 이를 데이터베이스에서 관계를 구성할 때 중간 테이블을 사용하여 구현된다.
우리는 ManyToMany를 사용한것으로 알고 사용하지만, 실제적으로 중간테이블과 관계를 맺게된다.

위의 예시의 경우 회원(Member Entity, 이하 Owner Entity)와 중간테이블(RewardMember Entity, 이하 Guest Entity)간의 매핑이 이루어지게된다. 
칭호(Reward Entity)에서도 마찬가지이다.

이때 Owner Entity에서는 **`@OneToMany`** 형태로 , Guest Entity에서는 **`@ManyToOne`** 형태로 매핑이 이루어지게된다.

이후 해당 관계를 사용하여 비즈니스 로직을 구성할 때, 수정 및 삽입 작업을 할때 마다 추가적인 조회 작업이 발생하여, 조회 성능이 떨어지게된다.


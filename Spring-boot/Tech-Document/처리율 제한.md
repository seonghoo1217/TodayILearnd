# 띱 - 개발일지
현재 진행중인 띱 프로젝트에서 한가지 의문점이 생겼다.

현재 이벤트 참여의 경우 별도의 제한이 없기에 사용자가 계속하여 클릭할 경우 패널티 없이 계속하여 이벤트 참여에 도전할 수 있다.

하지만 서비스의 특성상 정확한 타이밍에 사용자가 요청을 전달하고 서버 상으로도 무수한 요청이 부하로 이어질 수 있기에(조회 쿼리가 클릭 당 발생) 이를 방지해야한다는 점에대해 고려사항이 생겼다.

**예시**
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAHlDv%2FbtskRQ3zSfX%2FB7PcD7PGNK1blZqlfr8EZ0%2Fimg.png)
- 실제 이미 프로덕션되는 서비스들의 경우 위와 같은 메시지가 발생한다.
- 보통 서버 안정을 위해 필수적으로 탑재하는 기능으로 전문 용어로 **처리율 제한 장치 (= Rate limiter = API Throttling)** 라고 부른다.

## **처리율 제한 장치 (= Rate limiter = API Throttling)**
- 한 줄로 정의하자면 클라이언트 또는 서비스가 보내는 트래픽 처리율을 제한하기 위한 장치이다.
- 트래픽이 과도하게 높아진 경우, 로드밸런서를 이용해 서버에 적절히 부하를 분산하는 방법을 사용하지만 그럼에도 처리율 제한이 필요한 이유는 무엇일까?

## 처리율 제한 장치의 목적
- 외부 공격으로 인한 리소스 고갈 방지
- 처리율을 제한함으로써 서버를 많지 않게 두거나 or 우선 순위가 높은 API에 더 많은 자원을 할당하는 방식으로 서버 리소스 절감
- 잘못된 이용 패턴으로 인해 유발된 트래픽을 막아 불필요한 서버 과부하를 방지 가능

**이를 띱에 적용해보자면?**
- 특정 횟수를 특정 시간안에 요청시 알림을 띄운다.
  - 예를들어 2초안에 5회이상 요청시
- 이벤트 참여 중복 요청 (DB 상에서 처리되어 있지만 고려사항)

## 처리율 제한 처리 지점
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbvvIQh%2FbtskQPR2Qcn%2FzpQ2b0CkuKGZEw7d4ydx11%2Fimg.png)
처리율 제한 장치는 클라이언트, 미들웨어, 서버 중 한 곳에 위치할 수 있다. 각각의 장단점은 다음과 같다.

| 위치 | 장점 | 단점                                                                             |
|------|------|--------------------------------------------------------------------------------|
| 클라이언트측 | 딱히 없음 | - 위변조가 쉽다. <br> - 모든 클라이언트의 구현을 통제하기 어렵다.                                      |
| 미들웨어측 | API gateway가 지원해주기에 비교적 구현이 쉽다. | - 미들웨어를 커스텀하기 어려울 수 있다. <br> - 미들웨어에 문제 발생 시 전체 처리율 제한 처리에도 문제가 생긴다.           |
| 서버측 | 자유롭게 처리율 제한 알고리즘을 선택할 수 있다. | - 처리율 제한 장치 구현 인력이 추가로 필요하다. |

만약 내가 MSA 환경이라 이미 API gateway를 사용 중이라면, 또는 처리율 제한 장치를 직접 구현할 리소스가 충분하지 않다면 미들웨어측에 구현하는 것이 좋다고하지만 MSA환경을 구성한 적이 없기에 애매한것같다.

## 처리율 제한 알고리즘
| 이름 | 동작 원리 | 특징 | 장점 | 단점 |
|------|------|------|------|------|
| 토큰 버킷 알고리즘 | 요청을 처리할 때마다 버킷에서 토큰을 꺼내 사용하는 방식. 토큰이 없다면 요청은 버려진다 (overflow) | 간단하고, 세간의 이해도도 높아 폭넓게 사용되는 중 | - 구현 쉽고 메모리 효율적 <br> - 짧은 시간에 집중되는 트래픽 커버 가능 <br> - 버킷에 토큰이 남았다면 무조건 요청이 시스템에 전달된다 | - 버킷 크기와 토큰 공급률을 정하기 까다롭다 (IP 주소마다 제한할 것인지, 초당 요청을 제한할 것인지에 따라 버킷 관리 달라짐) |
| 누출 버킷 알고리즘 | 큐에 자리가 있는지 확인한 후, 빈 자리가 있으면 요청을 추가한다. 큐가 가득 찼다면 요청은 버려진다 (overflow) | 요청 처리율이 고정된 FIFO 큐로 구현 | - 큐 크기가 제한적이기에 메모리 효율적 <br> - 처리율이 고정되어 안정적 출력 가능 | - 단시간에 많은 트래픽이 몰릴 경우, 이전 요청을 처리하지 못함에 따라 새 요청이 버려질 수 있다. <br> - 버킷 크기와 처리율을 관리하기 힘들다. |

| 이름 | 동작 원리 | 특징 | 장점 | 단점 |
|------|------|------|------|------|
| 고정 윈도 카운터 알고리즘 | 타임라인을 고정 간격의 윈도로 나누고, 윈도마다 카운터를 붙인다. 카운터가 임계에 도달하면 요청은 새 윈도가 열릴 때까지 버려진다 (overflow) | - | - 메모리 효율적 <br> - 특정 패턴의 트래픽을 처리하기에 적합 | - 윈도 경계 부근에 일시적인 트래픽이 발생할 경우, 기대했던 처리 한도를 초과할 수 있다. |
| 이동 윈도 로깅 알고리즘 | 요청의 타임스탬프를 이용해, 새 요청이 오면 만료된 타임스탬프는 제거하고 신규 요청의 타임스탬프를 로그에 추가한다. 로그의 크기가 임계치에 닿으면 요청은 버려진다 (oveflow) | 고정 윈도의 윈도 부근 트래픽 문제 해결 | - 모든 순간에서 윈도의 허용 요청 개수가 시스템 처리 한도를 만족한다. | - 거부된 요청의 타임스탬프도 보관해야 하므로 메모리가 많이 필요하다. |
| 이동 윈도 카운터 알고리즘 | 현재 1분 간의 요청 수 + 직전 1분 간의 요청수 * 이동 윈도와 직전 1분이 겹치는 비율을 이용해 현재 윈도의 요청 수를 계산한다. | 고정 윈도 카운터 + 이동 윈도 로깅 | - 버스트 트래픽에 대응하기 좋다. <br> - 메모리 효율적 | - 직전 시간대 요청이 균등하게 분포되어 있다고 가정하기에 비교적 느슨하다. |

## 카운터 관리 방법과 관련 HTTP Header
위 알고리즘들이 모두 추적 대상별 카운터를 생성하고, 카운터가 임계치를 넘어설 경우 요청을 거부하는 매커니즘을 기반으로 동작한다.

해당 카운터를 저장하는 방식은 보통 로컬 캐싱 스토리지 또는 Redis와 같은 외부 캐싱 스토리지를 사용한다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb0rtm0%2FbtskLrdrZli%2FLk2DGyKqHke3phsybUXMzk%2Fimg.png)

그렇기에 요청 Flow를 구성 해보자면(Redis 사용한다는 가정하에)

1. 클라이언트 요청을 보낸다.
2. 미들웨어에서 Redis를 이용하여 현재 카운터의 한도를 검사한다.
3. 한도가 넘지 않았다면 요청처리
   - 한도가 초과되어 버려지는 Request는 HTTP Header를 통해 클라이언트에게 overflow 되었다고 전달
   - 관련 HttpHeader
     - **X-Ratelimit-Limit**: 클라이언트가 보낼 수 있는 API별 총 요청 한도.
     - **X-Ratelimit-Remaining** : 남은 API 요청 횟수. 이 횟수 만큼 추가 요청을 보낼 수 있다.
     - **X-Ratelimit-Retry-After** : 다음 API 요청을 시도하기 전에 대기해야 하는 시간
     - **X-Ratelimit-Reset** : 요청 최댓값이 재설정 될 때까지의 시간
     - **X-Daily-Requests-Left** : API 요청에서 사용 가능한 남은 일일 요청 횟수

## 이외의 고려사항
- 분산 환경에서의 구현
- 카운터를 확인하는 로직의 성능최적화 (비동기 처리 등, @EventListenr 사용)
- 클라이언트는 어떻게 처리율 제한을 회피할 수 있는지
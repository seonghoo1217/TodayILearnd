# @PatchMapping

최근 진행중이던 프로젝트의 MVP 기능 중 하나인 투두리스트 API를 개발하던 중 문득 한가지 의문이 생겼다.

해당 투두리스트의 **요구사항**으로는 `Drag & Drop`을 통해 카테고리를 바꿀수 있어야하고 이를 서버 로직에 적용시켜본다면, 전체 리소스가 아닌 일부의 리소스만이 변경된다.

투두에는 아래와 같은 데이터들이 포함되어있다.

```java
public class Todo{
	
	private Long todoSeq;
	
	private String name;
	
	private String contents;
	
	private Category categorySeq;
}
```

여기서 생긴 의문은 Drag&Drop을 통해 소속된 카테고리만 바꾸는데(이 말은 즉, 투두 자체의 데이터에는 변화가 없다) 과연 `@PutMapping`으로 해당 API 요청을 처리하는 것이 맞는지 의문이 생겼다.

## 🤔 Put vs Patch?
대부분의 사람들은 알고 있겠지만, Put 요청의 경우 수정하기 위한 데이터를 받으면 그 데이터를 활용하여 아예 새로운 리소스를 생성해 기존의 리소스와 바꿔치기 해버린다.

즉, 불필요한 데이터 변경까지 이루어지기에 메모리 손실쪽에서의 자원 손실이 발생할 수 있다.

하지만, Patch의 경우 변경하고자하는 리소스에 일부분만을 변경하는 것이 가능하다. 

또한 기능의 요구사항이 하나의 투두는 반드시 카테고리에 속해있어야하기 때문에, 기본값이 보장되는 Patch 옵션을 사용하여 API를 수정하는 것을 맞다고 생각했다.


## 유의 사항
Patch로 바꾸면서 아래와 같은 유의점들을 겪었다.

1. 일관성 유지의 어려움 
   - API 통신중 네트워크 장애가 발생한다면, Put의 경우 리소스를 전체 변경하는 옵션이기에 요청이 완벽하게 서버 쪽에 전달되지 못했다면, 클라이언트에선 이를 재요청하거나 장애를 일으키고 끝이난다.
   - 하지만, Patch의 경우 일부 리소스를 변경하기에 네트워크 장애를 맞닥드린 경우 최악의 경우에 일부 리소스 변경 후(수정 작업이 일어난 후) 장애를 일으킬 수 있다.
   - 이는 일관성 유지의 어려움으로 이어지기에 변경된 리소스를 찾아 복구하는 등의 작업이 필요해지게 된다.

2. 보안성
   - Put의 경우 요청온 데이터 모두에게 유효성 검사를 거쳐 옳바른 데이터 양식인지 아닌지를 판단가능하지만 Patch의 경우 이 작업이 어려웠다.
   - 데이터 단위가 아닌 Type 단위로 날라오는 값에 제약을 걸어야하기에, 별도로 patch로 오는 요청인지를 파악하는 로직이 필요했다.

하지만, Patch를 사용하는 것이 Rest 아키텍처의 의미론적으로도 맞는 옵션이며, 메모리 최적화 등의 이점 또한 얻을 수 있기에 Patch 옵션을 사용해 해당 API를 리팩터링했다.
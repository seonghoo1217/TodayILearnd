## Spring Test Framework
스프링에서 대표적으로 사용되는 테스트 프레임워크는 Unit 단위의 테스트를 지원하는 2가지 존재한다.

1. Junit : 자바에서 가장 흔히 사용되는 프레임워크
2. Mockito : 객체를 mocking하여 테스트를 도와준다.

스프링부트에서는 이 두 프레임워크를 지원하며, 간단한 설정만으로도 테스트 코드를 작성하게 도와준다.

## 테스트 코드를 왜 작성하는가?
사실 개발을 맨 처음 공부하며, 테스트 코드의 필요성에 대해서는 고려하지 않았던 부분이 컸다.

하지만, 최근에 들어서 주니어 개발자에게도 필수적인 요소로 자리매김 하며 권장되고 있다.
이러한 이유는 TDD 즉, 테스트 주도 개발 방법을 사용하였을 때의 이점이 크기 때문일 것이다.

그러한 이점과 더불어 테스트 코드를 작성하는 이유는 크게 3가지 정도로 나누어 볼 수 있다.

1. 빠른 피드백 : 테스트 코드를 작성하며, 개발을 진행하기에 이는 빠른 피드백으로 작용하여 결함이나 버그등을 조기에 발견하고 예방이 가능하다.

2. 리팩터링에 유려한 코드 : 기본적으로 Unit 단위로 테스트 코드를 작성하는 만큼, 테스트 케이스에 대한 가독성과 유지보수 성을 높일 수 있다.

3. 코드 품질 상향 : 결함과 확장성을 고려하며 개발을 진행하기에, 전체적인 코드의 질이 높아진다.

위의 이점들은 개발 향상에 있어 절대적지 않은 부분을 차지한다.

필자의 경우 스프링부트로 여러 프로젝트를 작업해왔지만, 한 프로젝트의 모든 비즈니스 로직에 Unit단위 테스트 케이스를 작성해본 경험은 없다.

아무래도 테스트 환경이 친숙하지 않을 뿐더러, 기능 개발에만 몰두했던 경험도 꽤나 컸을 것이다.

하지만, 몇 안되는 테스트 코드를 작성하며 생각보다 많은 이점을 얻은 경험이 존재한다.

우선적으로, 서버 개발자로서 가장 기피하고 싶은 에러 종류인 `Runtime`에서의 에러를 방지하는데 효과적이었으며, 
이후 기능이 추가됨에 따라 요구사항이 변경될 점을 고려하며 테스트 케이스를 작성한 경험은 추후 확장성과 유지보수성을 고려한 설계를 할 수 있었다.

이 처럼 테스트 코드가 가져오는 이점은 상당히 크기에 스프링 프레임워크에서 가장 많이 사용하는 프레임워크와 그 견해에 대해 짧막하게 작성하려한다.

## Junit
`Junit`은 기본적으로 Java 개발자라면, 한 번쯤은 사용해본 테스트 프레임워크이다.

Junit의 가장 큰 특징으로는 Unit 단위의 테스트를 작성 및 실행할 수 있는 환경을 제공하며, 간단하다는 것이 가장 큰 장점으로 꼽힌다.

Junit으로 테스트 코드를 간단하게 작성할 수 이유는 Java 기반의 테스트 프레임워크로서, `Annotation`을 지원하며 메소드 단위로 실행할 수 있다는 점이다.

그렇기에 코드 작성 난이도가 낮으며 대부분의 개발자들이 선호하는 테스트 프레임워크이다.

Junit의 경우 보통 `Assert` 클래스를 많이 이용하여 테스트를 진행하며, Assert는 테스트 결과값을 검증하는데 많이 사용됩니다.

이를 비즈니스 로직에 적용하여 API 반환 값이 예상과 다른 경우를 방지하고, 장애를 발생시킨다면 어느 지점인지 파악하는 용도로 많이 사용된다.


## Mockito
Mockitio 또한 자바 기반의 테스트 프레임워크로 가장 큰 장점은 동적 프록시(가짜 객체)를 이용한 의존성 환경 테스트이다.

여기서 유의해야할 점은 객체 원본이 아닌 프록시 객체를 이용한 Mock 객체를 이용할 수 있다는 점이다.

해당 방법을 이용한다면 해당 객체의 메소드, 의존성을 그대로 사용할 수 있으며 실제 원본(Original) 객체를 사용하는 것과 같은 효과를 낸다.

보통 의존성이 존재하는 코드를 테스트하기 위해 사용되며, 그 외에도 여러 장점이 존재한다.

1. 테스트의 안정성과 격리성이 보장
    - 가짜 객체를 사용하면 테스트 환경에서 모든 종속성을 완전히 제어할 수 있으므로 테스트의 안정성과 격리성이 보장되어, 테스트의 신뢰성을 높일 수 있다.
2. 개발 생산성이 향상
    - 가짜 객체를 사용하여 테스트를 작성하면, 실제 객체를 만들 필요가 없으므로 개발 생산성이 향상된다.
    - 가짜 객체를 만들기 쉽고 빠르며, 더 높은 수준의 추상화를 제공하여 코드의 가독성을 높일 수 있다.
3. 코드 변경에 대한 영향을 최소화
    - 가짜 객체를 사용하면 실제 객체와 동일한 인터페이스를 가진 객체를 만들 수 있으므로, 코드 변경에 대한 영향을 최소화할 수 있다.

## 🤔 Junit vs Mockito
필자의 경우 테스트 케이스를 작성하는데 있어서, 보통 Junit을 많이 이용한다. 테스트를 간단히 만들고 실행시키는데에 초점이 맞추어진 프레임워크이기 때문이다.

**`Junit`**은 앞서말한대로, 테스트 케이스를 작성하고 실행하는 데 특화되어 있어 테스트의 유효성을 검사하고 테스트 결과를 파악하기가 쉽다.
또한 Java를 기반으로하여 제공되는 어노테이션을 기반으로 빠른 코드작성으로 인해 개발 생산성인 높아진다.

그렇기 때문에 간편성과 생산성에 초점을 맞춘 테스트 프레임워크라고 할 수 있다.

하지만, 간편성에 걸맞게 값의 유효성을 보통 검사하는 용도로 사용되기에 다양한 테스트 케이스를 작성하는 것이 어렵다.
또한 각 객체의 의존성을 지원하지 않아 이를 직접 설정한다면 오랜시간 동안 설정을 하는데 시간을 소비하게된다.

이로 인해 , 독립적이여야하는 테스트 케이스간에 종속성이 발생하기도 한다.

`Mockito`는 Junit과 반대로 가장 큰 장점이 의존성이 존재하는 코드를 테스트할 수 있으며, 실제 객체가 아닌 가짜 객체를 통해 테스트 할 수 있다는 점이다.
이를 통해, 각 객체간의 상호작용 테스트를 진행하기에 좋으며, 가짜 객체에 여러 경우를 부여하며 다양한 상황을 테스트 케이스로 검증할 수 있다.

하지만, 이에 따라 가짜 객체가 원본과 차이가 생겨 예상치 못한 문제를 야기하거나, 가짜 객체 생성에 많은 코드가 소요된다는 점도 생긴다.
